Index: user/find.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by SGX on 2022/3/30.\n//\n\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n#include \"kernel/fcntl.h\"\n\nchar *\nfmtname(char *path) {\n    char *p;\n    while (p = path + strlen(path); *p != '/' && p >= path; p--)\n        ;\n    p++;\n    return p;\n}\n\nvoid find(char *path, char *target)\n{\n    char buf[505], *p;\n    int fd;\n    struct dirent de;\n    struct stat st;\n\n    if (!strcmp(fmtname(path), target)) {\n        printf(\"%s\\n\", path);\n        return ;\n    }\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        fprintf(2, \"find: can't open %s\\n\", path);\n        return ;\n    }\n    if (fstat(fd, &st) < 0) {\n        fprintf(2, \"find: can't stat %s\", path);\n        close(fd);\n        return ;\n    }\n\n    if (st.type != T_DIR) {\n        close(fd);\n        return ;\n    }\n\n    //DIR\n    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){\n        printf(\"ls: path too long\\n\");\n        close(fd);\n        return ;\n    }\n    strcpy(buf, path);\n    p = buf+strlen(buf);\n    *p++ = '/';\n    while(read(fd, &de, sizeof (de)) == sizeof (de)) {\n        if (de.inum == 0)\n            continue;\n        memmove(p, de.name, DIRSIZ);\n        p[DIRSIZ] = 0;\n\n        //path = oldpath + filename\n\n        if (!strcmp(de.name, \".\") || !strcmp(de.name, \"..\"))\n            continue;\n        find(buf, target);\n    }\n    close(fd);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        fprintf(2, \"usage: find <dirname> <filename>\");\n        exit(1);\n    }\n    find(argv[1], argv[2]);\n    exit(0);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/user/find.c b/user/find.c
--- a/user/find.c	(revision 28e15c0b487094fe0968615224592b863fb2773e)
+++ b/user/find.c	(date 1648731339379)
@@ -1,13 +1,10 @@
-//
-// Created by SGX on 2022/3/30.
-//
-
 #include "kernel/types.h"
 #include "kernel/stat.h"
 #include "user/user.h"
 #include "kernel/fs.h"
 #include "kernel/fcntl.h"
 
+<<<<<<< HEAD
 char *
 fmtname(char *path) {
     char *p;
@@ -61,6 +58,7 @@
 
         //path = oldpath + filename
 
+
         if (!strcmp(de.name, ".") || !strcmp(de.name, ".."))
             continue;
         find(buf, target);
@@ -75,4 +73,83 @@
     }
     find(argv[1], argv[2]);
     exit(0);
-}
\ No newline at end of file
+}
+=======
+char*
+fmtname(char *path)
+{
+	char *p;
+
+	// Find first character after last slash.
+	for(p=path+strlen(path); p >= path && *p != '/'; p--)
+		;
+	p++;
+
+	return p;
+}
+
+void
+find(char *path, char *targetname) 
+{
+	char buf[512], *p;
+	int fd;
+	struct dirent de;
+	struct stat st;
+
+	if (!strcmp(fmtname(path), targetname)) {
+		printf("%s\n", path);
+	}
+
+	if ((fd = open(path, O_RDONLY)) < 0) {
+		fprintf(2, "find: cannot open [%s], fd=%d\n", path, fd);
+		return;
+	}
+
+	if (fstat(fd, &st) < 0) {
+		fprintf(2, "find: cannot stat %s\n", path);
+		close(fd);
+		return;
+	}
+
+	if (st.type != T_DIR) {
+		close(fd);
+		return;
+	}
+
+	// st.type == T_DIR
+	
+	if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
+		printf("find: path too long\n");
+		close(fd);
+		return;
+	}
+	strcpy(buf, path);
+	p = buf+strlen(buf);
+	*p++ = '/';
+	while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+		if (de.inum == 0)
+			continue;
+		memmove(p, de.name, DIRSIZ);
+		p[DIRSIZ] = 0;
+		
+		if (!strcmp(de.name, ".") || !strcmp(de.name, ".."))
+			continue;
+
+		find(buf, targetname);
+	}
+	close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+	if(argc < 3){
+		fprintf(2, "usage: find path filename\n");
+		exit(1);
+	}
+
+	find(argv[1], argv[2]);
+
+	exit(0);
+}
+>>>>>>> origin/master
